---
params:
  boj: 1040
  bojTitle: 정수
---

## 문제 내용

$0 \cdots 9$ 숫자 중에 정확히 $K$종류만 사용되는 양의 정수 중에서, $N$ 이상이면서 최소인 것을 구하세요. 이 수는 $0$으로 시작할 수 없습니다.

### 입력

입력은 한 줄이며, $N$과 $K$가 주어집니다. $N$은 $10^{18}$보다 작거나 같은 양의 정수, $K$는 $10$보다 작거나 같은 양의 정수입니다.

### 출력

한 줄로 정답을 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

정답을 $M$이라고 하고, $N$과 $M$의 자릿수를 각각 $l_N$, $l_M$이라고 합시다.

먼저 $l_M > l_N$인 경우부터 살펴봅시다. $K$가 $l_N$보다 크거나, 후술할 $l_M = l_N$ 경우에서 조건을 만족하는 $M$이 없을 때 여기에 해당합니다. 이때는 $l_M = \max(l_N + 1, K)$이고, $l_M$자리 수 중에서 숫자가 $K$종류 사용되는 제일 작은 것을 구하면 됩니다. 예를 들어 $l_M = 8, K = 5$라면 $M = 10000234$가 됩니다.

이제 $l_M = l_N$인 경우를 봅시다. $N$의 가장 높은 자리($i = 0$)부터 차례대로 보는 백트래킹을 떠올릴 수 있지만, 단순하게 구현하면 너무 오래 걸리기 때문에 일부 탐색을 재활용할 수 있도록 DP를 설계해야 합니다.

DP의 각 상태마다 필요한 정보는 아래와 같습니다.
* 지금 몇 번째 자리를 보고 있는지 $i \in [0, l_N]$
* 지금까지 무슨 숫자들을 사용했는지 (bitmask) $\in [0, 2^{10})$
* $M$의 $0 \cdots (i - 1)$번째 자리들이 *전부* $N$의 그것들과 일치하는지 여부 $\in \{true, false\}$

세 번째 정보가 필요한 이유는 $N$ 이상인 자연수들만 살펴야 하기 때문입니다. 이 값이 참이라면 $M$의 $i$번째 자리숫자는 $N$의 $i$번째 자리숫자 이상만 고를 수 있고, 거짓이라면 이미 $N$보다 커진 상황이니 어떤 숫자든 고를 수 있습니다.

따라서 위의 3가지 정보를 묶어서 상태로 정의하고, 방문 배열을 관리하면서 백트래킹을 하면 정답을 구할 수 있습니다. 어떤 상태에 방문했다가 정답을 찾지 못한 채로 return할 때, 그 사실을 표시하여 나중에 같은 상태에 다시 방문하지 않도록 구현하면 됩니다.

{{< /details >}}
