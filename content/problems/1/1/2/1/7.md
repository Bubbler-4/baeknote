---
params:
  boj: 11217
  bojTitle: Spock
---

## 문제 내용

Rock-paper-scissors-lizard-Spock을 플레이하는 AI를 상대로 적어도 80% 이상을 승리하는 프로그램을 작성하세요. 게임의 규칙은 지문의 그림을 참조하세요.
각 화살표에서 화살표의 시작점에 있는 수가 끝점에 있는 수를 이긴다는 의미입니다. 두 플레이어가 같은 수를 내면 비기며, 어느 누구의 승리로도 인정되지 않습니다.

이 AI는 다음과 같이 동작합니다.

* $p = 127$은 소수입니다.
* 최초에 이 AI는 세 개의 수 $a, b, x$를 미리 정합니다. $0 \le a, b, x < p$입니다.
* 매 게임마다, $x \leftarrow (ax + b) \bmod p$로 $x$를 업데이트하고, $x \bmod 5$의 값에 해당하는 수를 냅니다. 지문의 표를 참조하세요.

### 인터랙션

이 문제는 인터랙티브 문제입니다. 먼저 플레이할 게임의 수 $r$이 주어집니다. ($100 \le r \le 1000$)

그 이후에는 각 게임에 대해 다음과 같이 입출력이 진행됩니다.

* 제출된 프로그램이 먼저 자신의 수를 출력하고 flush합니다. 이 단어는 `rock`, `paper`, `scissors`, `lizard`, `Spock` 중 하나여야 합니다. (대소문자 주의)
* 그러면 인터랙터가 자신의 수를 출력합니다. 이 역시 다섯 개 단어 중 하나로 주어집니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

먼저 처음 세 게임에 대해 아무거나 내고 AI의 수를 읽습니다. $i$번째 라운드에서의 $x$의 값을 $x_i$라고 하면, $x_1, x_2, x_3$의 후보가 각각 최대 26개가 나오므로 $26^3$가지 조합에 대해 다음의 방정식을 풀 수 있습니다.

$$
\begin{align*}
ax_1 + b = x_2 (\bmod p) \\
ax_2 + b = x_3 (\bmod p)
\end{align*}
$$

$x_1 = x_2$일 경우 방정식을 풀 수 없음에 유의합니다. 하지만 $x_1 = x_2$이면 $x_2 = x_3$이 되어야 하고, 이때의 $a$와 $b$는 $x_1 \neq x_2 = x_3$인 경우와 동일하므로 고려하지 않아도 됩니다.

이제 남은 턴 동안 다음과 같이 진행합니다.

* 각각의 $(a, b, x)$ 조합에 대해 다음 $x$값을 계산합니다.
* 가장 많은 조합을 이기는 수를 출력합니다.
* AI의 다음 수를 읽어 그 수와 $x \bmod 5$가 일치하는 조합만 남깁니다.

이렇게 하면, 매 턴 가능한 조합의 수가 약 5분의 1로 감소하므로 10턴 정도 이후에는 한 가지 가능성만 남아 반드시 항상 승리합니다.

{{< /details >}}
