---
params:
  boj: 11897
  bojTitle: 간선 파괴
---

## 문제 내용

정점 $V$개, 간선 $E$개로 이루어진 무방향 단순 그래프가 주어집니다. 각 간선에는 $1$부터 $E$까지의 번호가 매겨져 있습니다.

다음의 쿼리 $Q$개를 처리하세요.

* `l r`: 주어진 그래프에서 $\ell$번 간선부터 $r$번 간선까지를 모두 지웠을 때, 연결 요소의 개수를 출력합니다.

### 입력

첫 번째 줄에 $V$와 $E$가 주어집니다. ($5 \le V \le 700$, $1 \le E \le 123\;456$)

다음 $E$개 줄에 걸쳐서 $1$번부터 $E$번까지의 간선이 순서대로 한 줄에 하나씩 주어집니다. 간선은 양 끝점의 정점 번호 $a$와 $b$로 주어집니다. ($1 \le a, b \le V$)

그다음 줄에 $Q$가 주어집니다. ($1 \le Q \le 50\;000$)

다음 $Q$개 줄에 걸쳐서 각 줄에 쿼리가 주어집니다. ($1 \le \ell, r \le E$)

### 출력

각 쿼리에 대해 그 쿼리의 답을 한 줄에 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

$\ell$번 간선에서 $r$번 간선까지를 모두 지웠을 때 남은 간선은 $1$번부터 $\ell-1$번, 그리고 $r+1$번부터 $E$번입니다. 따라서, 간선 목록의 prefix와 suffix를 전처리해 놓으면
쿼리에 걸리는 시간을 줄일 수 있을 것 같습니다.

전처리는 전체 간선 목록을 앞에서 뒤 순서로, 그리고 뒤에서 앞 순서로 보면서, 그래프에 간선을 추가했을 때 연결 요소의 개수가 바뀌는 시점의 간선들만을 남깁니다.
그러면 prefix와 suffix에서 각각 $V$개의 간선이 남습니다.

이제 각 쿼리에 대해, prefix와 suffix에서 해당 쿼리에 대해 추가해야 하는 간선들을 뽑아서 유니온 파인드를 할 수 있습니다. 이렇게 하면 모든 쿼리를 처리하는 시간은
$\mathcal{O}(QV \log V)$가 됩니다. 이때 amortized로 시간을 줄여주는 path compression, path halving 등을 쓸 경우에는 비효율적인 상태를 중복 방문할 수 있으므로,
쿼리 당 확정 로그 시간을 달성할 수 있는 union by rank나 union by size만을 쓰는 것이 안전합니다.

{{< /details >}}
