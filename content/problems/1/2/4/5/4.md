---
params:
  boj: 12454
  bojTitle: カードシャッフル (Large)
---

## 문제 내용

1 이상 $M$ 이하의 서로 다른 정수가 하나씩 쓰여 있는 $M$장의 카드로 이루어진 덱이 있습니다. 맨 처음에는 맨 위부터 $1, 2, \cdots, M$의 순서로 쌓여 있습니다.

다음의 쿼리를 $C$번 수행한 뒤에, 맨 위에서 $W$번째 카드에 쓰여 있는 수를 출력하세요.

* $A_i, B_i$: 맨 위에서 $A_i$번째 카드부터 아래쪽으로 연속한 $B_i$장의 카드를 덱에서 제거하여, 그대로 덱의 맨 위로 옮깁니다.

### 입력

첫 줄에는 테스트 케이스의 개수 $T$가 주어집니다. ($1 \le T \le 200$)

각 테스트 케이스에 대해, 첫 줄에는 $M$, $C$, $W$의 값이 주어집니다. ($1 \le M \le 10^9$, $1 \le C \le 100$, $1 \le W \le M$)

다음 $C$줄에는 쿼리가 하나씩 주어집니다. ($1 \le A_i, B_i \le M$, $1 \le A_i + B_i - 1 \le M$)

### 출력

각 테스트 케이스에 대해, 문제의 정답을 `Case #{테스트 케이스 번호}: {문제의 정답}`의 형식으로 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

카드의 수가 많지만 쿼리의 수는 같으므로, 다음과 같은 방법으로 효율적으로 시뮬레이션할 수 있습니다.

* $a, a+1, a+2, \cdots, b-1, b$의 카드들이 연속으로 쌓여 있는 경우, 이를 구간 $(a, b)$로 요약할 수 있습니다.
* 맨 처음에는 $(1, M)$의 하나의 구간만 있습니다.
* 각 쿼리 $A_i, B_i$에 대해, $A_i$번째 카드의 뒤쪽이 어떤 구간 $(x, y)$의 내부에 있다면, 그 구간을 $(x, A_i)$와 $(A_i+1, y)$로 나눌 수 있습니다.
* $A_i + B_i - 1$번째 카드의 뒤쪽에 대해서도 마찬가지로 처리합니다.
* 그러고 나면 덱의 위로 옮겨질 구간들을 골라 Small에서처럼 리스트 연산을 이용해 옮겨줄 수 있습니다.

이 과정에서, 하나의 쿼리를 처리할 때마다 구간의 개수는 최대 2 증가하므로, 총 시간 복잡도는 $\mathcal{O}(TC^2)$입니다.

{{< /details >}}
