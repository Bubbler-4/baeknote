---
params:
  boj: 12815
  bojTitle: Dynamic memory allocation
---

## 문제 내용

길이 $n$의 메모리 공간이 있고, 각 공간은 순서대로 0부터 $n-1$까지의 번호가 붙어 있습니다. 처음에 이 공간은 비어 있습니다. $q$개의 쿼리를 처리하세요.

* `1 l`: `l`칸의 연속한 메모리를 할당하고, 그 중 첫 번째 메모리 공간의 번호를 출력합니다. 가능한 위치가 여러 가지라면, 그 중 첫 번째 메모리 공간의 번호가 가장 작은 것을 선택합니다.
  그러한 위치가 없다면 `-1`을 출력하고, 메모리를 할당하지 않습니다.
* `2 x l`: `x`번 메모리부터 오른쪽으로 `l`칸의 연속한 메모리를 할당 해제하고, 그 중에서 실제로 할당되어 있었던 메모리의 칸 수를 출력합니다.

### 입력

첫 줄에는 $n$과 $q$의 값이 주어집니다. ($1 \le n, q \le 3 \times 10^5$)

다음 $q$줄에는 쿼리가 한 줄에 하나씩 주어집니다. 1번 쿼리의 경우, $1 \le l \le n$을 충족합니다. 2번 쿼리의 경우, $0 \le x \le n-1$, $1 \le l \le n-x$입니다.

### 출력

각 쿼리의 출력을 한 줄에 하나씩 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

이 문제는 하나의 트리맵과 하나의 세그먼트 트리로 풀 수 있습니다. 둘 모두 (어떤 연속한 공간의 첫 번째 메모리 번호 $x$, 그 공간의 길이 $l$)의 쌍에 대해 동작하며, 각각 다음과 같이 정의합니다.

* 트리맵: 각각의 $(x, l)$ 쌍에 대해, 키에 $x$, 값에 $l$을 저장합니다.
* 세그먼트 트리: 길이 $n$의 max 세그먼트 트리를 만듭니다. 각각의 $(x, l)$ 쌍에 대해 인덱스 $x$에 $l$을 넣고, 그 외의 모든 자리의 값은 0으로 둡니다.

이제 각 쿼리를 다음과 같이 처리할 수 있습니다.

* 1번 쿼리: 먼저 세그먼트 트리의 전체 구간을 쿼리하여, 그 값이 $l$ 미만이면 `-1`입니다. $l$ 이상이라면 그러한 최소 인덱스를 검색해야 하는데, 이는 세그워크를 사용하여 구할 수 있습니다.
  왼쪽 구간의 max가 $l$ 이상이면 왼쪽으로, 그렇지 않으면 오른쪽으로 재귀하면 됩니다. $(x_{cur}, l_{cur})$에서 $x_{cur}$를 출력하고 이 쌍을 제거한 다음, $l_{cur} > l$이면 $(x_{cur}+l, l_{cur}-l)$을 삽입합니다.
* 2번 쿼리: 트리맵에서 시작점이 $x$ 이상 $x+l$ 이하인 모든 구간을 확인하고, 각 구간이 쿼리된 구간과 겹치는 길이를 모두 빼 줍니다. 시작점이 $x$ 미만인 것 중 가장 큰 구간 또한 확인해야 합니다.
  확인된 구간들 중 쿼리된 구간과 겹치거나 이어지는 모든 구간들을 트리맵과 세그먼트 트리에서 제거하고, 그들의 합집합을 삽입합니다.

각 쿼리에서 추가되는 구간의 개수는 최대 +1개이므로, 2번 쿼리에서 제거되는 구간의 수의 총합은 $\mathcal{O}(q)$가 됩니다. 따라서 전체 프로그램은 $\mathcal{O}(q \log n)$에 동작합니다.

{{< /details >}}
