---
params:
  boj: 1601
  bojTitle: 바이너리 파워 비숍
---

## 문제 내용

생략

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

일단 판을 45도 돌려서 비숍의 이동을 룩과 같은 이동으로 바꿉니다. 그러면 이동 규칙이 $(x + 2^k, y), (x - 2^k, y), (x, y + 2^k), (x, y - 2^k)$로 바뀝니다. 원래의 목적지의 $x$와 $y$좌표의 홀짝이 다르다면 이러한 점은 존재하지 않습니다.
이 변환으로 얻은 새로운 목적지 좌표를 다시 $(x, y)$라고 합시다.

목적지의 좌표의 홀짝에 따라 다음과 같은 관찰이 가능합니다.

* $x$와 $y$가 모두 홀수이면, 1칸짜리 이동은 한 번만 가능하므로 $(x, y)$로는 이동할 수 없습니다.
* $x$와 $y$가 모두 짝수이면, 1칸짜리 이동을 써서는 $(x, y)$로 이동할 수 없으며, 추가 이동 없이 $(\frac{x}{2}, \frac{y}{2})$으로 가는 모든 이동을 2배 하면 됩니다.
* $x$만 홀수이면, $x$방향으로 1칸 이동을 하고 모두 짝수인 것과 같이 좌표를 반으로 나눠서 재귀할 수 있는데, 2가지 선택지가 있습니다.
* $y$만 홀수인 경우도 마찬가지입니다.

2가지 선택지 중에서 어느 것을 고를지 알기 어렵습니다. 적당한 입력으로 시뮬레이션을 해보면 좌표를 반으로 나눌 때마다 생기는 가능성이 최대 2가지임을 알 수 있으므로, 탑다운 DP를 시도할 수 있습니다.

그런데 $(0, 1)$ 등의 위치에서 무한 재귀에 당할 수 있으므로, $(0, 0)$ 포함 5개의 base case를 지정해 준 다음 위의 알고리즘을 돌려 줍니다. DP로 구현하였으므로 선택지가 두 가지인 경우에는 둘 중 길이가 짧은 것을 고를 수 있습니다.

경로를 찾았다면, 그 경로의 모든 좌표들을 다시 45도 돌려서 출력해 줍니다.

{{< /details >}}
