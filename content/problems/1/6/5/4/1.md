---
params:
  boj: 16541
  bojTitle: Robots
---

## 문제 내용

A와 B로만 이루어진 문자열 위에서 좌우로 움직일 수 있는 두 대의 로봇이 있습니다. 주어진 문자열이 **좋은 문자열**인지 판정하도록 두 대의 로봇을 조종하는 프로그램을 작성하세요.

다음의 조건을 모두 충족하는 문자열은 **좋은 문자열**입니다.

* 주어진 문자열의 길이는 3의 배수입니다.
* 이 문자열을 길이가 같은 세 개의 구간으로 나누었을 때, 가운데 구간에 들어있는 A의 개수와 B의 개수가 서로 같습니다.

로봇 프로그램은 다음의 형식을 갖습니다.

```
Robot 1
<rule-or-comment>
<rule-or-comment>
...
<rule-or-comment>
Robot 2
<rule-or-comment>
<rule-or-comment>
...
<rule-or-comment>

```

마지막에 줄바꿈이 있지 않으면 채점기가 제출된 프로그램을 온전히 인식하지 못할 수도 있습니다.

`<rule-or-comment>`의 EBNF-like syntax는 다음과 같습니다.

```
<rule-or-comment> : <rule> | <comment>
<rule> : [LIR?] [OT?] [AB?] [01?]{4} "->" ([LRS][01?]{4} | [YN])
<comment> : "%" (any string)
```

각 로봇은 다음 단위시간에서의 동작을 결정하기 위해 다음의 정보를 참고할 수 있습니다.

* 이 로봇이 문자열의 맨 왼쪽 끝에 있다면 `L` (left), 오른쪽 끝에 있다면 `R` (right), 그 외의 글자 위에 있다면 `I` (inner)입니다.
* 다른 로봇이 이 로봇과 같은 칸에 서 있다면 `T` (two), 아니라면 `O` (one)입니다.
* 이 로봇이 서 있는 칸에 쓰여있는 글자가 A라면 `A`, B라면 `B`입니다.
* 이 로봇은 4비트의 메모리를 갖습니다. 각각의 행동 뒤에 메모리의 내용을 그대로 두거나 바꿀 수 있습니다.

로봇은 좌변이 현재 상황과 일치하는 첫 번째 규칙을 찾아서, 그 규칙의 우변대로 행동합니다. 규칙의 모든 자리에는 `?`이 올 수 있으며, 이는 그 칸이 어느 상태이든 상관없다는 뜻입니다.

* `Y`, `N`: 주어진 문자열이 좋은 문자열임, 또는 좋은 문자열이 아님을 선언하고 프로그램을 종료합니다. 하나의 로봇이 동작을 종료하면 다른 로봇도 같이 종료됩니다. 두 로봇이 동시에 선언하면 1번 로봇의 선언을 출력으로 인정합니다.
* `L`, `R`, `S`: 이 로봇을 왼쪽이나 오른쪽으로 한 칸 움직이거나, 그 자리에 가만히 있습니다. 이 경우, 이 글자의 오른쪽에 있는 4개의 비트로 메모리를 업데이트합니다. `?`가 적힌 칸은 그대로 둡니다.

프로그램이 시작할 때, 두 로봇은 모두 문자열의 맨 왼쪽 칸에 있으며, 메모리는 `0000`으로 초기화되어 있습니다.

로봇이 문자열의 밖으로 나가거나 현재 로봇의 상태와 일치하는 규칙이 없다면 실행이 즉시 종료되며 오답으로 처리됩니다.

### 제한

* 각각의 문자열에 대해, 문자열의 길이의 1000배의 단위 시간을 소모하면 오답으로 처리됩니다.
* 각 문자열의 길이는 12 이상 3600 이하이며, 각 테스트 파일은 16개 또는 20개의 문자열로 이루어져 있습니다. 테스트는 총 10개의 테스트 파일로 이루어져 있습니다.
* 1개의 테스트는 길이 12의 문자열만을 포함합니다.
* 다른 2개의 테스트는 길이 36 이하의 문자열만을 포함합니다.

### 점수

* 각 테스트 파일에 대해 모든 문자열을 올바르게 판정하면 10점씩을 받습니다. 총점은 100점이며, 100점을 받아야 AC로 인정됩니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

문자열의 길이가 3600 이하라는 것은 1200 이하의 수를 올바르게 세면 되며, $4 \times 5 \times 7 \times 9 = 1260$이므로 이러한 4개의 값으로 $(A - B) \bmod k$를 계산해서 판정하는 전략을 먼저 생각할 수 있는데,
문자열의 중간만 체크하려면 각 모듈로 $k$에 대해 적어도 $2k$개의 상태가 필요하게 됩니다. 따라서 부분점수를 긁을 수는 있으나 AC를 받기는 어렵습니다.

의도된 풀이는 시간축을 활용하는 것입니다. 예를 들면 다음의 풀이가 가능합니다.

* 먼저 두 로봇을 2/3 지점으로 이동합니다.
  * 로봇 1은 1/2의 속도로 오른쪽으로 이동하고, 로봇 2는 1의 속도로 오른쪽으로 이동하여 오른쪽 끝에 닿으면 다시 1의 속도로 왼쪽으로 이동합니다.
  * 로봇 1이 올바르지 않은 타이밍에 로봇 2와 만났거나, 서로를 지나쳐 갔다면 문자열의 길이가 3의 배수가 아닌 것으로 보고 `N`을 출력합니다.
* 두 로봇을 각각 반대 방향으로 반사시키면서 A와 B의 개수를 세는데, A와 B에서 이동속도를 다르게 주어서 가운데의 A와 B의 개수가 같을 때만 정확히 1/3 지점에서 만나도록 합니다.
  * 로봇 1: 왼쪽으로 갈 때 A이면 속도 1, B이면 속도 1/2; 오른쪽으로 갈 때 A이면 속도 1/2, B이면 속도 1
  * 로봇 2: 오른쪽으로 갈 때 A이면 속도 1, B이면 속도 1/2; 왼쪽으로 갈 때 A이면 속도 1/2, B이면 속도 1
* 이제 두 로봇이 정확히 1/3 지점에 있을 때만 오른쪽 끝에 정확히 같이 진입하도록 합니다. 이 부분은 첫 번째 부분과 비슷하게 작성하면 됩니다.

{{< /details >}}
