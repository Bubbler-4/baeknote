---
draft: true
params:
  boj: 16632
  bojTitle: Monitoring Ski Paths
---

## 문제 내용

노드가 $n$개이고 엣지가 $k$개인 포레스트가 주어집니다. 이 포레스트 상에서 ancestor-descendent 관계인 두 노드를 끝점으로 하는 경로가 $k$개 주어집니다. 몇 개의 노드를 선택하여 모든 경로 상에 선택된 노드가 하나 이상 포함되도록 하고자 할 때, 선택해야 하는 노드의 개수의 최솟값을 구하세요.

### 입력

첫 줄에는 $n$, $k$, $m$의 값이 주어집니다. ($2 \le n \le 250\;000$, $1 \le k < n$, $1 \le m \le 250\;000$)

다음 $k$줄에는 노드 번호의 쌍 $(x, y)$가 주어집니다. 이는 노드 $x$가 노드 $y$의 부모라는 뜻입니다.

다음 $m$줄에는 노드 번호의 쌍 $(x, y)$가 주어집니다. 이는 ancestor 노드 $x$에서 descendant 노드 $y$를 잇는 경로를 나타냅니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

각각의 경로를 후손에서 조상 쪽으로 거슬러 올라가는 것으로 보면, 시작 노드의 번호와 이동 횟수의 쌍으로 나타낼 수 있습니다. 이 이동 횟수는 각 노드의 depth를 구한 뒤 두 depth의 차이로 구할 수 있습니다.

리프 노드에서 시작하는 경로는 그 경로가 당장 끝나는 것이 아니라면 리프가 아닌 정점을 선택하는 것이 반드시 이득입니다. 이때 각 경로는 그 리프의 부모 노드에서 시작해서 1 적은 이동 횟수만큼 이동하는 경로로 변환됩니다.

당장 끝난다면 그 리프 노드를 선택하고, 같은 리프 노드에서 시작하는 모든 경로를 제거할 수 있습니다.

같은 리프 노드에서 시작하는 두 경로가 있다면, 그 중 이동 횟수가 적은 것만 보면 됩니다. 어차피 이동 횟수가 적은 것이 제거될 때 같이 제거되거나, 다른 리프 노드에서 올라온 더 짧은 경로가 제거될 때 같이 제거될 것이기 때문입니다.

따라서, 각 노드에서 시작하는 경로들 중 이동 횟수의 최솟값을 트리 DP로 구해 가면서 선택된 노드의 개수를 구하면 됩니다.

{{% /details %}}
