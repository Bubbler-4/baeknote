---
params:
  boj: 17992
  bojTitle: Computer Cache
---

## 문제 내용

$n$칸짜리 캐시와 $m$개의 원본 데이터가 있습니다. $i$번째 원본 데이터의 길이는 $k_i$입니다. 처음에 캐시는 모두 0으로 초기화되어 있습니다. 이때 다음의 쿼리를 처리하세요.

* `1 i p`: $i$번 원본 데이터 전체를 복사해서 캐시의 $p$번째 칸부터 $p + k_i - 1$번째 칸까지 순서대로 채웁니다. ($1 \le i \le m$, $1 \le p$, $p + k_i - 1 \le n$)
* `2 p`: 캐시의 $p$번째 칸의 값을 출력합니다. ($1 \le p \le n$)
* `3 i l r`: $i$번 원본 데이터에서 $l$번째부터 $r$번째 칸의 값들을 1씩 증가시킵니다. 각 칸에는 1바이트만 들어가며, 따라서 이 연산은 $\bmod 256$으로 처리됩니다.
  이 연산은 이미 캐시에 있는 $i$번 데이터의 복사본에는 영향을 주지 않습니다. ($1 \le i \le m$, $1 \le l \le r \le k_i$)

### 입력

첫 줄에는 $n$, $m$, 그리고 쿼리의 개수 $q$가 주어집니다. ($1 \le n, m, q \le 5 \times 10^5$)

다음 $m$줄에는 원본 데이터가 주어집니다. 이들 중 $i$번째 줄의 첫 번째 수는 그 데이터의 길이 $k_i$이며, 그 다음에 $k_i$개의 255 이하의 음이 아닌 정수가 주어집니다.

다음 $q$줄에는 쿼리가 문제 내용의 형식대로 주어집니다. 2번 쿼리는 적어도 하나 주어집니다.

$k_i$의 총합은 $5 \times 10^5$를 초과하지 않습니다.

### 출력

각각의 2번 쿼리에 대해 답을 한 줄에 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

캐시를 효율적으로 관리하기 위해서는 캐시의 각 칸이 원본 데이터를 가리킬 수 있도록 해야 합니다. 그런데 원본 데이터가 버전이 존재하므로, 퍼시스턴트 세그먼트 트리를 써서 관리할 수 있습니다.

이 세그먼트 트리를 하나만 만들기 위해 모든 원본 데이터를 하나의 배열에 몰아넣습니다. 그리고 3번 쿼리의 구간 업데이트를 처리하기 위해서는 레이지를 써도 되고 차분 배열을 써도 됩니다.

이제 캐시의 각 칸이 원본 데이터를 가리키려면 *버전*과 *인덱스*의 두 개의 정보가 필요합니다. 버전은 구간 덮어쓰기이고, 인덱스는 구간을 공차 1의 등차수열로 덮어쓰는 것과 같습니다.

이를 효율적으로 처리하는 한 가지 방법은 역시 차분 배열을 쓰는 것입니다. 모든 칸에 $(0, 1)$을 기본값으로 두고, $l$번째와 $r$번째 사이의 값을 업데이트하기 위해서는 기존의 $(0, l-1)$ 쿼리 결과와 $(0, r)$ 쿼리 결과를 보고
$(0, l)$과 $(0, r+1)$의 쿼리 값이 원하는 대로 나오도록 적당한 값을 $l$번째와 $r+1$번째에 대입하면 됩니다. 그 사이에 $(0, 1)$이 아닌 값들을 덮어쓰는 것은 별도의 min이나 max 세그먼트 트리를 둬서 업데이트되었던 위치들을 모두 찾아
롤백해줄 수 있습니다. 롤백이 발생하는 횟수는 최대 $2q$회입니다.

{{< /details >}}
