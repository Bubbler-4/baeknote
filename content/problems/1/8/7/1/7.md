---
params:
  boj: 18717
  bojTitle: Instructions (Hard)
---

## 문제 내용

아래와 같은 비트 연산을 사용하여, $2^{64}$ 미만의 양의 정수 $A$가 주어졌을 때 $A$보다 크면서 1 비트의 개수가 $A$와 같은 가장 작은 정수를 구하는 프로그램을 제출하세요.
프로그램의 명령의 수는 **300**을 초과하면 안 됩니다.

`R`은 레지스터 이름이어야 하며, `X`는 레지스터 이름이거나 10진수 상수일 수 있습니다. 레지스터는 `A`부터 `Z`까지 26개가 있으며, `A`에는 입력 정수가 들어있고, 그 외의 레지스터는 처음에 0으로 초기화됩니다.
프로그램이 끝났을 때는 레지스터 `A`에 문제의 정답이 있어야 하며, 다른 레지스터는 어떤 값이든 상관 없습니다.

* `mov R X`: `R = X`
* `and R X`: `R = R & X`
* `or R X`: `R = R | X`
* `xor R X`: `R = R ^ X`
* `not R`: `R = ~R`
* `shl R X`: `R = R << X`
* `shr R X`: `R = R >> X`

`shl`과 `shr`의 경우, 시프트를 수행한 뒤 빈 공간은 0으로 채워지며, $X \ge 64$이면 `R`의 값은 0이 됩니다.

프로그램에는 가독성을 위해 빈 줄을 추가할 수 있으며, 이는 명령의 수에 포함되지 않습니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

이진수 $A$의 next permutation을 구하는 문제이고, 이는 다음과 같이 표현할 수 있습니다.

* $A$가 `01{a}0{b}`로 끝날 때, 이러한 $a+b+1$자리를 `10{b+1}1{a-1}`로 바꿉니다.

이를 해결할 수 있는 한 가지 방법은 다음과 같습니다.

* 먼저 `1{64-b}0{b}`를 구합니다. 이는 $A$의 LSB(가장 낮은 1 비트)를 왼쪽으로 복사하여 구할 수 있고, 다음과 같이 하면 됩니다. 이 값을 $B$라고 합시다.
  * `mov B A; mov C B; shl C 1; or B C; mov C B; shl C 2; or B C; ...; mov C B; shl C 32; or B C`
* 다음으로 `1{64-a-b}0{a+b}`를 구합니다. 이는 `A ^ B`에 같은 루틴을 적용하여 구할 수 있습니다. 이 값을 $C$라고 합시다.
* 이제 `and A C`로 마지막 $a+b$자리를 0으로 덮어쓰고, $C$에 shl과 xor를 사용하여 오른쪽 끝에서 $a+b+1$번째 자리만 1인 수를 만든 뒤 이를 $A$에 or하여 그 자리를 1로 만들어 줍니다.
* 마지막으로 마지막 $a-1$자리가 1인 수를 만들어야 합니다. 이를 위해 `xor B C`를 하여 연속 $a$개의 1이 있는 수를 만들고, 다음과 같이 맨 끝의 0을 하나씩 제거하는 것을 63번 반복해줄 수 있습니다.
  * `mov E B; not E; and E 1; shr B E`
* shr를 한 번 더 적용하여 길이를 1 줄이고, 그 결과를 $A$에 or 해 줍니다.

이러한 전체 프로그램을 올바르게 구현했다면 정확히 299개의 명령을 사용하여 문제의 제한을 통과합니다.

{{< /details >}}
