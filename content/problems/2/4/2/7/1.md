---
params:
  boj: 24271
  bojTitle: xor²
---

## 문제 내용

생략

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

먼저, 길이 $N$의 수열 뒤를 0으로 채워서 길이 $2^k$의 수열로 확장할 수 있습니다. 그러면 1번 쿼리에서 $0 \le i < N$ 부분을 무시할 수 있습니다.
그리고 나면 $0 \le (i \oplus x) < l$인 $i$의 집합은 $0 \le (i \oplus x) \le r$인 $i$의 집합의 부분집합임을 알 수 있으며, 같은 두 수를 XOR하면 서로 상쇄되므로 prefix 쿼리로 문제를 단순화할 수 있습니다.

조건을 살짝 바꿔서 $0 \le (i \oplus x) < r$인 $i$의 집합을 분석해 봅시다.

* $r$의 마지막 비트가 0이면, 임의의 $i$에 대해 마지막 비트를 바꿔도 부등식의 참거짓은 바뀌지 않습니다.
* $r$의 마지막 비트가 1이면, $r-1$에 대한 $i$의 집합에 $(r-1) \oplus x$를 추가한 것과 같으므로, 전자로 환원할 수 있습니다.

전자의 경우를 빠르게 구하기 위해서, 주어진 수열을 두 개씩 XOR한 값의 수열을 만들면, 기존 집합에 대한 $a_i$의 XOR합은 새로운 수열에서 $0 \le (i \oplus \lfloor \frac{x}{2} \rfloor) < \frac{r}{2}$에 해당하는 $a_i$의 XOR합과 같아집니다.
동일하게 재귀적으로 반씩 줄여 나간 결과를 모두 기록해 놓으면 prefix XOR합을 $\log N$ 시간에 구할 수 있습니다.

이렇게 만들어진 결과의 기록은 XOR 세그먼트 트리와 동일하므로, 2번 쿼리는 $i$번 인덱스가 포함된 구간들에 대해 업데이트를 해주면 역시 $\log N$ 시간에 처리할 수 있습니다.

{{< /details >}}
