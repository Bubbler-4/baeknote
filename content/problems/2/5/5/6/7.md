---
params:
  boj: 25567
  bojTitle: 줄 세우기
---

## 문제 내용

생략

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

쿼리에 따라 줄이 점점 합쳐지므로 disjoint set을 써야겠다고 생각할 수 있습니다. 각 쿼리의 시간 복잡도를 $\mathcal{O} (\log n)$으로 유지하기 위해서 union by rank를 사용합니다.

이제 각 노드에 추가 정보를 저장하여 원하는 답이 나오도록 해 봅시다.

각 노드 $i$에 대해서 각 줄의 맨 앞에서부터 자기 자신까지의 합 $S_i$를 알 수 있으면 2번 쿼리를 해결할 수 있습니다. 그런데 이를 모든 노드가 직접 들고 있으면 집합이 합쳐질 때마다 서브트리의 모든 노드가 업데이트 되어야 합니다.

따라서 업데이트는 union 이전의 두 루트에서만 이루어지도록 하는 방법을 생각해 보면, 트리에서 자기 자신부터 루트까지의 합이 $S_i$가 되도록 할 수 있습니다. 이를 저장한 배열을 `psum`이라고 합시다.
그리고 이를 업데이트하기 위해, 각 루트는 그 서브트리의 모든 노드의 합도 알고 있어야 합니다. 이를 `sum`이라고 합시다. 그러면 다음의 과정을 거쳐서 업데이트를 수행하면 쿼리에서 올바른 값을 얻을 수 있습니다.

* 오른쪽 루트를 왼쪽 루트의 자식으로 두는 경우
  * `psum[r2] += sum[r1] - psum[r1]`
    * 왼쪽 서브트리는 이미 올바른 값을 나타내고 있으므로 건드리지 않고, 오른쪽 서브트리의 모든 원소에 `sum[r1]`을 더한 효과를 얻어야 합니다.
    * 그런데 자식 관계로 인해 `psum[r1]`이 더해진 상황이므로 이를 offset해 줍니다.
  * `sum[r1] += sum[r2]`
* 왼쪽 루트를 오른쪽 루트의 자식으로 두는 경우
  * `psum[r2] += sum[r1]`
    * 오른쪽 서브트리가 올바른 값을 갖도록 합니다.
  * `psum[r1] -= psum[r2]`
    * 왼쪽 서브트리는 값이 바뀌면 안되므로, 자식 관계로 인해 더해진 `psum[r2]`를 offset해 줍니다.
  * `sum[r2] += sum[r1]`

{{% /details %}}
