---
params:
  boj: 25900
  bojTitle: Count the Dividing Pairs
---

## 문제 내용

$n$개의 음이 아닌 정수로 이루어진 수열 $A_1, A_2, \cdots, A_n$이 주어집니다. 두 인덱스 $i$와 $j$에 대해 $A_i \ne A_j$이면서 $A_i$가 $A_j$의 약수인 쌍 $(i, j)$의 개수를 구하세요.
0은 0이 아닌 어떤 수의 약수도 아니며, 모든 수는 0의 약수입니다.

### 입력

첫 줄에는 테스트 케이스의 개수가 주어집니다.

각 테스트 케이스에 대해, 첫 줄에는 $n$이 주어지며, 다음 줄에는 수열 $A_1, A_2, \cdots, A_n$이 주어집니다. ($2 \le n \le 10^6$, $0 \le A_i \le 10^7$)

### 출력

각 테스트 케이스에 대해 `Test case #{테스트 케이스 번호}: {정답}`과 같이 출력합니다. 각 테스트 케이스 사이에는 빈 줄을 하나 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

$k = 10^7$ 길이의 배열에 각 수의 개수를 저장한 뒤 1 이상 $k$ 이하의 수들에 대해 모든 배수를 확인하는 것으로 $\mathcal{O}(k \log k)$ 풀이를 얻을 수 있는데, 여기에 아무 변형을 하지 않으면 TLE를 받습니다.

다음과 같은 여러 가지 상수커팅 방법을 적용해 보면 통과할 수 있습니다.

* $10^7$ 길이의 배열을 한 번만 만들고 재사용합니다. 개수를 초기화할 때는 수열에 있는 수들만 방문하여 0으로 만듭니다.
* 0과 0이 아닌 수를 짝지으면 모두 해당이 되므로, 0의 개수가 $x$일 때 $x(n-x)$를 더하고 그 이후 0은 모두 무시합니다.
* 1 이상 $10^7$ 이하의 모든 수에 대해 그 수의 배수를 확인할 것이 아니라, 수열에 있는 수만 확인해도 됩니다.
  그러나 같은 수에 대해 여러 번 반복하면 시간 복잡도가 깨지므로, 수열에서 중복을 제거한 뒤에 구하거나 visited 배열을 사용하는 등의 방법을 쓸 수 있습니다. 작성자의 뇌피셜로는 후자가 빠를 것 같습니다.

{{< /details >}}
