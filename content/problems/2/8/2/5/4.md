---
params:
  boj: 28254
  bojTitle: 트리와 깃발
---

## 문제 내용

$N$개의 정점이 있는 트리와 $M$종류의 깃발이 있습니다. 각 정점에는 0개 이상 $M$개 이하의 서로 다른 깃발이 꽂혀 있습니다. 모든 정점에 꽂혀 있는 모든 깃발의 개수의 합은 $500\;000$ 이하입니다.

$N-1$개의 간선 각각에 대해, 트리에서 그 간선을 제거한 상태에서 서로 다른 두 연결 요소에서 같은 종류의 깃발을 하나씩 고르는 방법의 수를 구하세요.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

먼저 주어진 트리에 루트를 지정하고 부모-자식 관계를 만듭니다. 그러면, 각각의 간선은 어떤 부모 정점과 자식 정점의 쌍을 연결하게 되고, 이 간선을 제거하면
자식 정점을 루트로 갖는 서브트리와 나머지로 나눠집니다. 따라서 각 정점에 대해 그 정점을 루트로 갖는 서브트리에 대해 필요한 값을 계산해 주면 됩니다.

여기서 필요한 값은 서브트리 내에서 각 종류의 깃발의 개수입니다. 각각의 깃발의 개수 $k$에 대해, 그 깃발의 전체 개수가 $m$일 때 $k(m-k)$의 합을 구하면 됩니다.
모든 정점에 대해 $M$개의 정보를 저장하는 것은 불가능하고, 개수가 0인 깃발은 답에 기여하는 값도 0이므로 무시하면, 각 정점에서 자식들의 counter를 합치는 것을 생각할 수 있습니다.

모든 깃발의 개수의 합을 $F$라고 할 때, counter를 나이브하게 합치는 것은 최악 $\mathcal{O}(NF)$ 시간이 걸립니다. 대신 small to large를 사용할 수 있는데,
가장 원소가 많은 counter를 가지고 있고 나머지 counter들의 원소들로 업데이트를 하는 방법입니다. 어떤 정점의 자식이 여러 개라면 한 번에 두 개씩 아무 순서로 합치면 되며,
이렇게 하면 $\mathcal{O}(N + F \log F)$ 시간을 달성할 수 있습니다. 어떤 깃발의 개수를 업데이트할 때에는 답의 값도 그 개수의 변동에 따라 같이 업데이트해 주어야 합니다.

이렇게 풀었을 때 러스트로는 기본 `HashMap`을 사용하면 통과하며, C++의 경우 `gp_hash_table`을 써야 할 수도 있습니다.

{{% /details %}}
