---
params:
  boj: 28835
  bojTitle: Оптимальное перестроение
---

## 문제 내용

길이 $n$의 순열 $a_1, a_2, \cdots, a_n$이 주어집니다. 순열에는 1 이상 $n$ 이하의 정수가 각각 정확히 한 번씩 등장합니다.

$1 \le i < j \le n$에 대해 $a_i > a_j$인 $(i, j)$의 쌍의 개수를 인버전의 개수라고 합니다.

다음의 연산을 정확히 한 번 수행하여 얻을 수 있는 순열 중에서 인버전의 개수가 가장 작은 것을 찾아 그 때의 인버전의 개수를 출력하세요.

* 연산: 정수 $k$를 선택하여, 값 $k$를 $k$번째 자리로 옮기고, $k$보다 작은 수는 $k$의 왼쪽으로, $k$보다 큰 수는 $k$의 오른쪽으로 옮깁니다.
  이때, $k$가 아니면서 $k$와의 대소관계가 같은 두 수의 상대적 위치는 바뀌지 않습니다. 파이썬 코드로 나타내면 다음과 같습니다.

```python
a = [...] # 입력 순열
[x for x in a if x < k] + [k] + [x for x in a if x > k]
```

### 입력

첫 줄에 $n$이 주어집니다. ($1 \le n \le 3\;000\;000$)

다음 줄에 순열의 각 수가 공백으로 구분되어 주어집니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

세그먼트 트리를 사용하여 인버전의 개수를 구하는 알고리즘의 응용으로 풀 수 있습니다.

$k$ 값으로 연산을 수행한 결과의 인버전의 개수는 원래의 순열에서 1 이상 $k-1$ 이하의 수들끼리 이루는 인버전의 개수와
$k+1$ 이상 $n$ 이하의 수들끼리 이루는 인버전의 개수의 합이 됩니다.

이를 구하기 위해, 수가 커지는 순으로 세그먼트 트리에 넣으면서 자기 자신보다 오른쪽에 있는 값들의 합을 구하면 각 수 $i$가 자신보다 작은 수와 이루는 인버전의 개수를 구할 수 있고, 이것의 누적 합을 구하여 전자를 해결할 수 있습니다. 후자는 같은 것을 반대 방향으로 한 번 더 수행하면 됩니다.

{{% /details %}}
