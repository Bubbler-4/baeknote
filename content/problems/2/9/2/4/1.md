---
params:
  boj: 29241
  bojTitle: Инверсии
---

## 문제 내용

길이 $n$의 수열 $a_1, a_2, \cdots, a_n$이 주어집니다. 이 수열에는 1부터 $n$까지의 정수가 정확히 한 번씩 등장합니다.

어떤 두 정수 $1 \le i < j \le n$에 대해 $a_i > a_j$이면 이러한 $i, j$의 쌍을 인버전이라고 합니다. 이때 다음 쿼리를 처리하세요.

* `x y`: 부분 배열 $a_x, a_{x+1}, \cdots, a_y$의 인버전의 개수를 출력합니다.

### 입력

첫 줄에는 $n$이 주어집니다. ($1 \le n \le 30\;000$) 다음 줄에는 수열 $a_1, a_2, \cdots, a_n$이 주어집니다.

그다음 줄에는 쿼리의 개수 $q$가 주어집니다. ($1 \le q \le 100\;000$) 다음 줄부터 $q$줄에 걸쳐서 각 줄에는 $x'_i, y'_i$가 주어집니다. ($1 \le x'_i, y'_i \le n$)

각 쿼리의 $x$와 $y$의 값은 다음과 같이 결정됩니다.

* 직전 쿼리의 답을 $Ans$라고 합시다. 첫 쿼리 이전에 $Ans$는 0입니다.
* $(x'_i + Ans - 1) \bmod n + 1$과 $(y'_i + Ans - 1) \bmod n + 1$의 값을 구합니다.
* $x$는 두 값 중 최솟값, $y$는 두 값 중 최댓값입니다.

### 출력

각 쿼리에 대해 답을 줄바꿈으로 구분하여 출력합니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

$\mathcal{O}(n^2)$ 전처리, 쿼리당 $\mathcal{O}(\frac{n}{W})$인 풀이가 통과합니다.

먼저, 구간 인버전의 개수를 prefix 인버전의 개수로 표현하면 다음의 식을 얻습니다.

$$inv(a[x..y]) = inv(a[1..y]) - inv(a[1..x-1]) - \sum_{i=1}^{x-1} \sum_{j=x}^{y} [a_i > a_j]$$

여기서 $[a_i > a_j]$는 $a_i > a_j$이면 1, 아니면 0을 뜻합니다. prefix 인버전은 일반적으로 세그먼트 트리를 사용한 인버전 구하는 방법을 이용하면 쉽게 구해 놓을 수 있습니다.

세 번째 항은 $[a_i > a_j]$의 2차원 누적합을 구해놓을 수 있다면 $\mathcal{O} (1)$에 구할 수 있겠지만, 아쉽게도 $n^2$개의 4바이트 정수를 저장하기에는 메모리 제한이 너무 작습니다.

이를 해결하기 위해, 해당 정보를 5줄 단위로 저장해 놓고, 그 사이를 채우기 위해 누적합을 적용하지 않은 $[a_i > a_j]$의 2차원 배열을 비트셋으로 만들어 놓고 매 쿼리마다 필요한 범위의 1의 개수를 세어주면
쿼리당 $\mathcal{O}(\frac{n}{W})$를 달성할 수 있습니다.

{{% /details %}}
