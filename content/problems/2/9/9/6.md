---
params:
  boj: 2996
  bojTitle: 큐브 모으기
---

## 문제 내용

생략

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

서로 변을 공유하지 않는 큐브 다섯 개가 닫힌 영역을 이룰 수 있는 방법은 네 개로 다이아몬드를 만드는 방법밖에 없습니다.
따라서, 다이아몬드가 없는 경우와 로봇이 처음에 다이아몬드 안에 있는 경우, 밖에 있는 경우로 나누어 접근할 수 있습니다.

일단 로봇이 다이아몬드 안에 있는 경우, 네 방향 중 하나를 밀고 나와서 다이아몬드가 없는 경우로 환원할 수 있습니다. 이때 큐브가 연결되지 않는 쪽을 선택합니다.

다이아몬드가 없다면, 각각의 큐브를 적절한 간격으로 떨어진 정해진 위치로 옮긴 다음 T자로 조립하는 방법이 있습니다. 이때, 다음의 행동을 하는 함수를 만들어 놓으면 크게 도움이 됩니다.

* 큐브를 옮기지 않고 현재 상태에서 BFS를 하여 로봇을 현재 좌표에서 다른 좌표로 이동시키는 함수
* 하나의 큐브를 선택하여 원하는 $x$좌표로 움직이는 함수
  * "큐브의 오른쪽으로 이동한 뒤 왼쪽으로 밀기"와 "큐브의 왼쪽으로 이동한 뒤 오른쪽으로 밀기"를 구현하면 됩니다.
    이때, 시작점과 끝점에서 큐브의 양쪽이 비어 있고 로봇이 그 지점으로 이동할 수 있으며, 큐브가 움직이는 동안 다른 큐브에 닿지 않음을 가정합니다. 이 조건은 함수를 사용하는 쪽에서 충족시켜야 합니다.
* 하나의 큐브를 선택하여 원하는 $y$좌표로 움직이는 함수
  * 위와 동일한 방식으로 구현합니다.

이러한 함수를 만들었다면, 예를 들어 다음의 방법으로 한 칸씩 띄어서 일렬로 나열할 수 있습니다. 정렬 순서와 큐브의 목적지의 순서로 인해, 이렇게 큐브를 움직이면 다른 큐브와 절대로 닿지 않게 됩니다.

* 큐브들을 $y$좌표가 큰 것부터 작은 것 순으로 나열합니다. $y$좌표가 같은 것 중에는 $x$좌표가 작은 것부터 나열합니다.
* 첫 번째 큐브를 $y = 20$까지 밀어 올리고, 그 다음 $x = 0$으로 밀어 줍니다.
* 두 번째 큐브를 같은 방식으로 $y = 18, x = 0$으로 이동하고, ..., 마지막 큐브를 $y = 12, x = 0$으로 이동합니다.

이제 맨 위쪽 두 개를 양쪽으로 한 칸씩 움직여서 아래로 밀어 T의 가로줄을 만들고, 아래쪽 두 개를 위로 밀어 T를 완성합니다.

다이아몬드가 있다면, 나머지 하나의 큐브를 잘 움직여서 다이아몬드의 아래에 놓고, 다이아몬드의 위쪽 큐브를 아래로 밀어 T를 만들 수 있습니다.

* 다이아몬드의 중심 좌표를 $(x_d, y_d)$라고 합시다. 다이아몬드에 속하지 않는 큐브를 찾아서, 그 큐브의 $x$좌표를 $x_d \pm 3$ 중 하나에 오도록 가로로 움직입니다. 이는 항상 가능함을 증명할 수 있습니다.
* 이제 이 큐브가 다이아몬드에서 가로로 충분히 떨어져 있으므로, $y$좌표를 $y_d - 3$에 오도록 세로로 움직이고, 그 다음 다시 $x$좌표를 $x_d$에 오도록 가로로 움직입니다.
* 이제 위아래 큐브를 밀어서 T자를 완성할 수 있습니다.

{{< /details >}}
