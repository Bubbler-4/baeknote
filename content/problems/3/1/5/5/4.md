---
title: BOJ 31554 Nap Sort
---

문제 링크: [{{< icon "boj" >}}](https://www.acmicpc.net/31554)

## 문제 내용

$N$ ($1 \le N \le 200\;000$) 개의 정수 $a_i$ ($1 \le a_i \le 10^{11}$)가 있습니다. 당신은 다음의 과정을 거쳐 이 수들을 정렬하려고 합니다.

* 과정을 시작하기 전에, 몇 개의 수를 골라 각각 로봇들에게 맡깁니다. 로봇은 충분히 많다고 가정합니다.
* 당신은 남아있는 수들을 가지고 다음의 과정을 반복합니다.
  * 남아있는 $k$개의 수들 중에서 최솟값을 찾아 그 수를 배열의 맨 뒤에 추가합니다. 이 과정은 $k$초가 소요됩니다.
* 각각의 로봇은 자신이 들고 있는 수가 $k$라면 전체 과정이 시작된지 $k$초 뒤에 그 수를 배열의 맨 뒤에 추가합니다.

당신과 어떤 로봇이 동시에 배열에 수를 추가하려고 하면, 당신이 추가하는 수가 먼저 추가됩니다.

여러 대의 로봇이 동시에 배열에 수를 추가하려고 하면, 모든 수가 동시에 추가됩니다.

정렬하는 데에 걸리는 최소 시간을 구하세요.

### 입력

첫 줄에는 테스트 케이스의 개수 $T$가 주어집니다. ($1 \le T \le 10$)

각 테스트 케이스에 대해, 첫 줄에는 수의 개수 $N$이 주어지고, 그 다음 줄에는 수의 목록이 주어집니다. 수는 중복될 수 있습니다.

수의 개수의 총합은 $200\;000$을 초과하지 않습니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

일반성을 잃지 않고, $a_i$들이 비내림차순으로 정렬되어 있다고 가정합니다.

당신이 처리할 수의 개수 $k$를 고정하면, 각각의 수를 로봇에게 맡겼을 때 그 앞에서 당신이 처리해야 하는 수의 개수가 정해집니다. 이를 $j_i$라고 합시다. 이 수열에 대해 다음과 같은 관찰을 할 수 있습니다.

* $j_i$는 단조증가 수열입니다.
* $\frac{k(k+1)}{2} \ge a_n$인 경우는 고려할 필요가 없습니다. (모든 수를 로봇에게 맡기는 것으로 시간 $a_n$을 달성할 수 있기 때문)
* 그렇지 않다고 가정하였을 때, $0 \le j_i \le k$이며, $j_n = k$입니다.

이제 여기서, "모든 선택되지 않은 수 $a_i$보다 작은 선택된 수의 개수가 $j_i$가 되도록" 수들을 선택해야 합니다. 이는 항상 가능함을 보일 수 있으며,
다음의 그리디 전략을 사용하면 로봇에게 넘긴 수 중 최댓값이 가장 작은 방법으로 수들이 선택됨을 보일 수 있습니다.

* $n - k$개의 수를 로봇에게 넘길 때까지, 수들을 작은 것부터 순서대로 다음과 같이 처리합니다.
  * 현재까지 선택된 수의 개수가 $j_i$와 같다면, $a_i$를 로봇에게 넘깁니다.
  * 그렇지 않다면, $a_i$를 선택합니다.

증명은 $k \le n$을 이용하여 수학적 귀납법으로 가능한 것 같습니다.

이제 $k$값을 증가시키면 각각의 $j_i$는 단조감소하고, 선택되는 수의 개수도 늘어나므로 로봇에게 넘긴 수 중 최댓값은 단조감소합니다. 반면 당신이 움직여야 하는 시간은 단조증가하므로,
"한 쪽 시간이 다른 쪽 시간을 초과하는가?"라는 질문에 대한 답은 최대 한 개의 경계를 가지며, 이를 이분탐색할 수 있습니다.

최종적으로 답은 이분탐색의 양쪽 경계에서 소요되는 시간 중 작은 값을 출력하면 됩니다. 구현 방법에 따라 `1 1 1 1 ... 1` 또는 `max max max ... max`의 엣지 케이스에 주의합니다.

{{% /details %}}
