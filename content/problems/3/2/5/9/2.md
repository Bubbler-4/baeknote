---
params:
  boj: 32592
  bojTitle: Intelligence Exploration
---

## 문제 내용

0과 1만으로 이루어진 길이 $N$의 배열 $a_1, a_2, \cdots, a_N$이 주어집니다. 이 배열에 대해 다음의 쿼리를 $Q$개 처리하세요.

* `l r`: $a_\ell \rightarrow a_{\ell+1} \rightarrow \cdots \rightarrow a_r$의 값을 계산합니다.

$x \rightarrow y$는 implies 연산자로, $(x, y) = (1, 0)$이면 0, 아니면 1입니다. 여러 개의 연산자가 있다면 왼쪽부터 묶어 계산합니다.

### 입력

첫 번째 줄에 배열의 길이 $N$이 주어집니다. ($2 \le N \le 100\;000$)

두 번째 줄에 배열의 원소들이 순서대로 한 줄에 주어집니다.

세 번째 줄에 쿼리의 개수 $Q$가 주어집니다. ($1 \le Q \le 100\;000$)

다음 줄부터 $Q$개의 줄에 걸쳐서, 각 줄에 쿼리가 한 줄에 하나씩 주어집니다. ($1 \le \ell < r \le N$)

### 출력

각 쿼리에 대해, 쿼리의 답을 한 줄에 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

어떤 구간에 대해, 그 구간의 마지막 수가 1이면 그 앞의 원소에 상관없이 답은 1입니다.

이를 응용하면, 어떤 구간에서 마지막으로 등장하는 1이 있다면 그 이전의 수들은 모두 무시할 수 있고, $1, 0, \cdots, 0$의 답과 동일한 답이 됩니다.

또한, $1, 0, \cdots, 0$에서 맨 앞의 $1 \rightarrow 0$은 0이므로 $0, \cdots, 0$으로 요약할 수 있습니다.

마지막으로, 0이 홀수 개이면 답은 0, 짝수 개이면 1이 됨을 알 수 있습니다.

이제 이를 이용하여 모든 쿼리에 대한 답을 빠르게 구하기 위해서는 다음과 같이 할 수 있습니다.

* 먼저, 각각의 인덱스 $i$에 대해, $i$번째에서 왼쪽으로 등장하는 연속된 0의 개수를 구해 놓습니다.
* 이제 각 쿼리에 대해, 그 쿼리가 갖는 마지막 0의 개수는 $r$번째에서 왼쪽으로 등장하는 0의 개수와 구간의 길이 중 작은 값입니다. 이 값의 홀짝에 따라 답을 출력하면 됩니다.

{{< /details >}}
