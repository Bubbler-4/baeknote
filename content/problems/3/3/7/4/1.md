---
params:
  boj: 33741
  bojTitle: actGenshinImp
---

## 문제 내용

$r$행 $c$열의 사각 격자의 각 칸에 알파벳 소문자가 하나씩 쓰여 있습니다. 한 칸에서 시작하여 상하좌우 네 방향 중 하나로 이웃한 칸으로 이동하는 것을 반복하면서 그 칸에 있는 글자를 적어 나갈 때,
같은 칸을 두 번 이상 밟지 않고 문자열 `genshinimpact`의 cyclic shift를 얻을 수 있는 방법의 수를 $998\;244\;353$으로 나눈 나머지를 구하세요.

어떤 문자열의 cyclic shift란, 그 문자열의 접두사 중 하나를 문자열의 맨 앞에서 떼서 맨 뒤에 붙인 것을 의미합니다.

### 입력

첫 줄에는 $r$과 $c$의 값이 주어집니다. ($1 \le r, c \le 500$)

그 다음에는 사각 격자가 주어집니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

문자열 `genshinimpact`는 `i`와 `n`을 제외하고 모든 글자가 서로 다릅니다. 또한 `ini`가 부분 문자열로 존재함을 이용하여, 다음과 같이 경우를 나눌 수 있습니다.

* `ini`를 포함하는 문자열: $0 \le k \le 10$에 대해 `"mpactgensh"[k:] + "ini" + "mpactgensh"[:k]`의 형태
* `ini`를 포함하지 않는 문자열: `nimpactgenshi`와 `impactgenshin` 중 하나

전자의 경우, `n`에서 네 방향으로 이웃한 `i` 중 하나로 이동한 다음에 `hsnegtcapm` 순서 또는 `mpactgensh` 순서로 방문하는 방법의 수를 구해 놓고, 각각의 $k$에 해당하는 prefix와 suffix의 길이에 대한 경우의 수의 곱을 더해주면 됩니다.
prefix와 suffix가 서로 같은 `i`를 사용할 수 없음에 주의하고, 중심의 `n`을 방문하려고 하는 경우도 제외해야 합니다.

후자의 경우, `impactgenshin`의 개수는 `nihsnegtcapmi`의 개수와 같습니다. 따라서 전자의 과정에서 prefix와 suffix 각각의 마지막에 `i`를 추가하여 필요한 값을 얻을 수 있습니다.

단순 탐색을 하기에는 경우의 수가 많기 때문에, `n`이나 `i`의 주변에서 각 글자가 등장하는 위치를 기록해놓은 다음에, 글자 순서로 경우의 수를 업데이트하는 DP를 사용할 수 있습니다.
토글링을 쓰고 DP 테이블을 초기화할 때도 0이 아닌 위치만 초기화하도록 구현하면 약 600ms대에 통과합니다.

{{% /details %}}
