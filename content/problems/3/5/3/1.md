---
params:
  boj: 3531
  bojTitle: Commuting Functions
---

## 문제 내용

두 함수 $f$와 $g$가 어떤 집합 $X$를 정의역과 공역으로 하는 함수일 때, 모든 $x \in X$에 대해 $f(g(x)) = g(f(x))$이면 $f$와 $g$가 교환가능하다고 합니다.

양의 정수 $n$에 대해 집합 $N_n = \{1, 2, \cdots, n\}$을 정의역과 공역으로 하는 함수 $f$가 $[f(1), f(2), \cdots, f(n)]$의 배열의 형태로 주어집니다. 이 함수는 일대일 대응 함수입니다. 즉, 함수값으로 $1, 2, \cdots, n$이 정확히 한 번씩 등장합니다.
이 함수 $f$와 교환 가능한 $g$들 중에서 사전 순으로 최소인 것을 찾아 출력하세요.

함수 $g_1$이 함수 $g_2$보다 사전 순으로 작다는 것은, 어떤 $i$($1 \le i \le n$)가 존재하여 모든 $j < i$에 대해 $g_1(j) = g_2(j)$이면서 $g_1(i) < g_2(i)$임을 의미합니다.

### 입력

첫 줄에는 $n$이 주어지고, 둘째 줄에는 $f(1), f(2), \cdots, f(n)$의 값이 주어집니다.

### 출력

문제의 조건을 충족하는 함수 $g$에 대해 $g(1), g(2), \cdots, g(n)$의 값을 한 줄에 출력합니다.

## 문제 풀이

{{% details title="스포일러" closed="true" %}}

사전 순으로 최소를 요구하고 있으므로 첫 번째 값부터 해결해 봅시다.

* $f(1) = 1$이면, $f(g(1)) = g(f(1)) \Leftrightarrow f(g(1)) = g(1)$입니다. $g(1) = 1$로 두면 등식이 성립합니다.
* $f(1) = x \ne 1$이면,
  * $f(g(1)) = g(x)$가 성립해야 합니다. $g(1) = 1$로 두면 $g(x) = f(1) = x$가 되며, 아직까지는 모순되지 않습니다.
  * $f(g(x)) = g(f(x))$에 의해 $g(f(x)) = f(x)$이며, 이를 반복하면 1을 포함하는 순열 사이클의 함수값이 모두 결정됩니다.

이제 $g(2)$가 아직 결정되지 않았다고 가정하고 이를 해결해 봅시다.

* $f(2) = 1$이라면 1이 속한 순열 사이클에 2도 속한다는 의미가 되므로 이는 불가능합니다.
* $f(2) = 2$이면, $f(g(2)) = g(f(2)) = g(2)$입니다. $f(1) = 1$이라면 $g(2) = 1$로 둘 수 있고, 아니면 $g(2) = 2$입니다.
* $f(2) = x > 2$이면,
  * $f(g(2)) = g(x)$가 성립해야 합니다. 만약 $g(2)$를 1로 두면, $g(x) = f(1)$이 됩니다. 이는 $g(f(2)) = f(1)$로 쓸 수 있습니다.
  * 앞의 경우와 마찬가지로 반복해 보면, $g(f^k(2)) = f^k(1)$이 됩니다. 이것이 문제가 없으려면 $f^k(2) = 2$일 때 $f^k(1) = 1$이어야 합니다. 이는 2를 포함한 순열 사이클의 길이가 1의 길이의 배수여야 성립합니다.
    그렇지 않으면 $g(2)$의 값으로 1을 쓸 수 없고, 2를 써야 합니다.

이를 종합하면 다음의 알고리즘을 얻을 수 있습니다.

* 1부터 $n$까지, 아직 $g(i)$가 정해지지 않은 $i$에 대해 다음을 수행합니다.
  * $i$를 포함하는 순열 사이클을 구합니다.
  * 기존의 사이클들을 시작 인덱스가 작은 것부터 확인하면서, 그 사이클의 길이가 현재 사이클의 길이의 약수인지 확인하고, 그렇다면 앞의 사이클의 값들로 뒤의 사이클의 인덱스에 채웁니다.
  * 그러한 사이클이 없다면, 현재 사이클의 함수값들을 자기 자신으로 채우고, 기존 사이클의 목록에 현재 사이클을 기록합니다.

이렇게 하면 서로 같은 길이의 사이클은 사이클의 목록에 들어가지 않으며, 서로 다른 길이의 사이클의 최대 개수는 $\mathcal{O} (\sqrt{n})$이므로 시간 내에 동작합니다.

{{% /details %}}
