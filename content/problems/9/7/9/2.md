---
params:
  boj: 9792
  bojTitle: Chorus
---

## 문제 내용

노래 가사가 하나의 문자열로 주어질 때, 이 문자열의 부분 문자열로 두 번 이상 등장하는 가장 긴 문자열을 후렴이라고 정의합니다. 이러한 부분 문자열은 여러 개일 수 있지만, 이들 중 어느 것을 선택하더라도 출력이 동일한 입력만 주어집니다.

$n$ ($1 \le n \le 15$)개의 노래 가사와 $q$ ($1 \le q \le 20$)개의 쿼리 문자열이 주어집니다. 각 쿼리 문자열에 대해, 그 쿼리 문자열을 후렴의 부분 문자열로 갖는 노래의 번호들을 모두 출력하세요.

### 입력

첫 줄에는 노래의 개수 $n$이 주어집니다. 다음 $n$줄에는 각 노래의 가사가 주어집니다. 가사의 모든 글자는 알파벳 소문자이며, 하나의 노래 가사의 길이는 1500글자 이하입니다.

그다음 줄에는 쿼리의 개수 $q$가 주어집니다. 다음 $q$줄에는 각 쿼리 문자열이 주어집니다. 쿼리 문자열 또한 알파벳 소문자로만 이루어져 있습니다.

### 출력

각 쿼리에 대해, 그 쿼리가 후렴에 등장하는 모든 노래의 번호를 한 줄에 순서대로 출력합니다. 노래의 번호는 0-based입니다. 즉 첫 번째 노래의 번호는 0번입니다. 그러한 노래가 한 개도 없다면 `-1`을 대신 출력합니다.

## 문제 풀이

{{< details title="스포일러" closed="true" >}}

데이터가 약한 것인지는 알 수 없으나, 노래 가사의 길이가 $s$일 때 $\mathcal{O}(s^2 \log s)$ 내지 $\mathcal{O}(s^3)$ 풀이가 모두 통과하는 것으로 보입니다.

일단 각 노래 가사의 후렴을 추출하는 것이 가장 어려운데, 1701번보다 제한이 작으므로 1701번 문제를 풀 수 있는 모든 방법으로 동일하게 풀 수 있습니다.

* 가능한 부분 문자열의 길이 $i$에 대해 길이 $i$의 부분 문자열을 모두 추출한 뒤 중복이 있는지 확인하는 루틴을 이용해 $i$에 대해 이분 탐색
* 위를 롤링 해시로 최적화
* KMP, Z 등을 $s$번 돌리기
* SA/LCP의 나이브 구현 등

그 이후에는 Python의 `in` 등으로 부분 문자열 체크를 하면 됩니다.

{{< /details >}}
